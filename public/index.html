<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Agent Builder</title>
<style>
  :root{--bg:#0b0c10;--card:#141824;--ink:#e9edf1;--muted:#9aa6b2;--accent:#5eead4;--line:#232735}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .wrap{max-width:980px;margin:32px auto;padding:0 20px}
  h1{margin:0 0 16px;font-size:26px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  label{display:block;font-weight:600;margin:12px 0 6px}
  select,textarea,input,button{width:100%;background:#0f1218;color:var(--ink);border:1px solid var(--line);border-radius:10px;padding:10px 12px}
  textarea{min-height:200px;font-family:ui-monospace,Consolas,Menlo,monospace;font-size:13px}
  button{cursor:pointer}
  .primary{background:var(--accent);color:#0b0c10;border:none;font-weight:700}
  .hint{color:var(--muted);font-size:13px}
  #suggestions{position:relative}
  .suggest-box{position:absolute;left:0;right:0;background:#0f1218;border:1px solid var(--line);border-radius:10px;margin-top:6px;max-height:260px;overflow:auto;z-index:10}
  .suggest-item{padding:8px 10px;cursor:pointer;display:flex;gap:8px;align-items:baseline}
  .suggest-item:hover{background:#121826}
  .suggest-id{font-family:ui-monospace,Consolas,Menlo,monospace;font-size:12px}
  .suggest-name{color:var(--muted);font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .dbg{font:12px/1.4 ui-monospace,Consolas,monospace;color:#aaa;margin-top:8px;word-break:break-word}
  .err{color:#fca5a5}
  .badges{display:flex;gap:8px;align-items:center;margin-top:8px}
  .badge{font-size:12px;border:1px solid var(--line);padding:4px 8px;border-radius:999px;color:var(--muted)}
  details{margin-top:10px}
</style>
</head>
<body>
<div class="wrap">
  <h1>AI Agent Builder</h1>

  <div class="card">
    <div class="row">
      <div>
        <label for="scenario">Scenario (<code>scenario_id</code>)</label>
        <select id="scenario"><option value="">Loading…</option></select>
      </div>
      <div>
        <label for="channel">Channel (auto)</label>
        <select id="channel">
          <option value="email">Email</option>
          <option value="sms">SMS (Twilio)</option>
          <option value="whatsapp">WhatsApp (Twilio)</option>
          <option value="call">Voice Call (Twilio)</option>
        </select>
      </div>
    </div>

    <label for="search">Search the full catalog (8k+)</label>
    <input id="search" placeholder="Type scenario_id or name…  e.g. tier1_dso_SCHEDULING_NO_SHOWS" autocomplete="off" />
    <div id="suggestions"></div>

    <div class="badges">
      <span id="archetypeBadge" class="badge">Archetype: —</span>
      <span id="channelsBadge" class="badge">Channels: —</span>
      <span id="aiBadge" class="badge">AI: —</span>
    </div>

    <label for="bp">Preview (JSON from /api/build)</label>
    <textarea id="bp" readonly></textarea>

    <div class="row" style="margin-top:10px">
      <button id="create" class="primary">Create workflow</button>
      <button id="download" disabled>Download n8n JSON</button>
    </div>
    <div class="hint">Top: PRODUCTION lane. Bottom: DEMO lane with your seeded contacts.</div>

    <details id="planBox" style="display:none">
      <summary>Show AI plan</summary>
      <pre id="plan" style="white-space:pre-wrap"></pre>
    </details>

    <div id="dbg" class="dbg"></div>
  </div>
</div>

<!-- Keep builder as a fallback ONLY (no defer/async). Bump version to bust cache if you change it. -->
<script src="/builder.js?v=23-safe-imports"></script>

<script>
/* ========== Small helpers ========== */
const $ = id => document.getElementById(id);
const scenarioSel = $('scenario'), channelSel = $('channel'),
      searchEl = $('search'), suggestWrap = $('suggestions'), bpTA = $('bp'),
      dbg = $('dbg'), aiBadge = $('aiBadge'), archetypeBadge=$('archetypeBadge'), channelsBadge=$('channelsBadge'),
      planBox=$('planBox'), planPre=$('plan');

let ALL = [], MAP = {};
let INDUSTRIES = [], IND_MAP = {};
let lastWorkflow = null, lastScenarioId = null;

function listify(v){ return Array.isArray(v) ? v : String(v ?? '')
  .replace(/^\[|\]$/g,'')
  .split(/[;,|\n|\|,]+/)
  .map(x=>x.replace(/^['"]|['"]$/g,'').trim())
  .filter(Boolean); }

async function getJSON(url){
  const r = await fetch(url, { cache:'no-store' });
  const raw = await r.text();
  try { return { ok:r.ok, status:r.status, json: JSON.parse(raw), raw }; }
  catch { return { ok:r.ok, status:r.status, json:null, raw }; }
}

function recommendedChannel(row){
  const shapes = listify(row.best_reply_shapes).map(x=>x.toLowerCase());
  const set = new Set(shapes.map(s =>
    s.includes('whatsapp')?'whatsapp':
    (s.includes('sms')||s.includes('text'))?'sms':
    (s.includes('voice')||s.includes('call'))?'call':
    s.includes('email')?'email':s));
  if (set.has('sms')) return 'sms';
  if (set.has('whatsapp')) return 'whatsapp';
  if (set.has('email')) return 'email';
  if (set.has('call')) return 'call';
  return 'email';
}
function matchIndustryForScenario(s){
  const key = (s.name||'').toLowerCase();
  return IND_MAP[key] || null;
}
function assertBuilder(){
  return (window.Builder && typeof window.Builder.buildWorkflowJSON === 'function');
}

/* ========== Normalize + ensure ========== */
function normalizeScenarioRecord(m){
  return {
    scenario_id: m.scenario_id||'',
    name: m.name||'',
    triggers: m.triggers||'',
    best_reply_shapes: listify(m.best_reply_shapes),
    risk_notes: m.risk_notes||'',
    agent_name: m.agent_name||'',
    how_it_works: m.how_it_works||'',
    tool_stack_dev: m.tool_stack_dev||'',
    tool_stack_autonomous: m.tool_stack_autonomous||'',
    roi_hypothesis: m.roi_hypothesis||'',
    tags: listify(m.tags||m['tags (;)']||'')
  };
}

async function ensureScenarioLoaded(idOrQuery){
  const id = String(idOrQuery||'').trim();
  if (!id) return null;
  if (MAP[id]) return MAP[id];
  const res = await getJSON(`/api/scenarios?q=${encodeURIComponent(id)}&max=1`);
  const items = (res.ok && res.json && Array.isArray(res.json.items)) ? res.json.items : [];
  if (!items.length) return null;
  const rec = normalizeScenarioRecord(items[0]);
  if (!rec.scenario_id) return null;
  MAP[rec.scenario_id] = rec;
  if (!Array.from(scenarioSel.options).some(o=>o.value===rec.scenario_id)){
    const o=document.createElement('option');
    o.value=rec.scenario_id; o.textContent=rec.scenario_id; o.title=rec.name||rec.scenario_id;
    scenarioSel.appendChild(o);
  }
  return rec;
}

function populateUI(list){
  scenarioSel.innerHTML = '';
  const frag = document.createDocumentFragment();
  list.forEach(s=>{
    const o=document.createElement('option');
    o.value=s.scenario_id; o.textContent=s.scenario_id; o.title=s.name||s.scenario_id;
    frag.appendChild(o);
  });
  scenarioSel.appendChild(frag);
  if (list.length) applyScenario(list[0].scenario_id);
}

function applyScenario(id){
  const s = MAP[id] || ALL.find(x=>x.scenario_id===id);
  if (!s) return;
  const industry = matchIndustryForScenario(s); // (not used here, reserved)
  scenarioSel.value = s.scenario_id;
  channelSel.value  = recommendedChannel(s);
}

/* ========== Search / suggestions ========== */
let searchTimer = null;
async function remoteSearch(q){
  if (!q || q.trim().length < 2){ suggestWrap.innerHTML=''; return; }
  const url = `/api/scenarios?q=${encodeURIComponent(q)}&limit=50`;
  const res = await getJSON(url);
  const items = (res.ok && res.json && Array.isArray(res.json.items)) ? res.json.items : [];
  renderSuggestions(items);
}
function renderSuggestions(matches){
  if (!matches || !matches.length){ suggestWrap.innerHTML=''; return; }
  const box = document.createElement('div'); box.className='suggest-box';
  box.innerHTML = matches.map(m=>{
    const id=(m.scenario_id||'').replace(/</g,'&lt;');
    const nm=(m.name||'').replace(/</g,'&lt;');
    return `<div class="suggest-item" data-id="${id}">
        <span class="suggest-id">${id}</span>
        <span class="suggest-name">${nm}</span>
      </div>`;
  }).join('');
  box.addEventListener('click', async (e)=>{
    const el = e.target.closest('.suggest-item'); if(!el) return;
    const id = el.getAttribute('data-id');
    const rec = await ensureScenarioLoaded(id);
    if (rec){ $('search').value = id; applyScenario(id); }
    suggestWrap.innerHTML='';
  });
  suggestWrap.innerHTML=''; suggestWrap.appendChild(box);
}
searchEl.addEventListener('input', e=>{
  clearTimeout(searchTimer);
  searchTimer = setTimeout(()=>remoteSearch(e.target.value), 180);
});
searchEl.addEventListener('focus', ()=> {
  if (ALL.length) renderSuggestions(ALL.slice(0,10));
});
searchEl.addEventListener('blur', ()=> setTimeout(()=>suggestWrap.innerHTML='',150));
searchEl.addEventListener('keydown', async (e)=>{
  if (e.key==='Enter'){
    const v = e.target.value.trim();
    const rec = await ensureScenarioLoaded(v);
    if (rec){ applyScenario(rec.scenario_id); suggestWrap.innerHTML=''; return; }
    remoteSearch(v);
  }
});
scenarioSel.addEventListener('change', ()=> applyScenario(scenarioSel.value));
channelSel.addEventListener('change', ()=> applyScenario(scenarioSel.value));

/* ========== Server build flow ========== */
const createBtn = document.getElementById('create');
const downloadBtn = document.getElementById('download');

async function buildOnServer(sid){
  const url = `/api/build?scenario_id=${encodeURIComponent(sid)}`;
  const r = await fetch(url, { method:'GET', cache:'no-store' });
  const j = await r.json();
  if (!j.ok) throw new Error(j.error || 'Build failed');
  // Update badges
  aiBadge.textContent = `AI: ${j.usedAI ? 'on' : 'off'}`;
  try {
    const wfName = (j.workflow && j.workflow.name) || 'AI Workflow';
    const nodes = (j.workflow && j.workflow.nodes) ? j.workflow.nodes.length : 0;
    const chans = [];
    // quick peek for channel leafs
    (j.workflow.nodes||[]).forEach(n=>{
      if (/Demo Send /i.test(n.name)) chans.push(n.name.replace('Demo Send ',''));
    });
    channelsBadge.textContent = `Channels: ${Array.from(new Set(chans)).join(', ') || '—'}`;
    const archGuess = wfName.split('—').pop()?.trim() || '—';
    archetypeBadge.textContent = `Archetype: ${archGuess}`;
  } catch {}
  // Show AI plan if present
  if (j.plan) { planBox.style.display='block'; planPre.textContent = JSON.stringify(j.plan, null, 2); }
  else { planBox.style.display='none'; planPre.textContent=''; }
  return j.workflow;
}

createBtn.addEventListener('click', async ()=>{
  try{
    dbg.textContent = '';
    createBtn.disabled = true; createBtn.textContent = 'Creating…';
    let sid = (scenarioSel.value||'').trim();
    if (!sid){
      const typed = (searchEl.value||'').trim();
      if (typed) {
        const rec = await ensureScenarioLoaded(typed);
        if (rec) sid = rec.scenario_id;
      }
    }
    if(!sid || !MAP[sid]) throw new Error('No scenario selected or found. Type a valid scenario_id and press Enter.');

    lastScenarioId = sid;

    // Prefer the server build; fallback to local builder if server fails
    let wf = null;
    try {
      wf = await buildOnServer(sid);
    } catch (e) {
      if (assertBuilder()){
        const s = MAP[sid];
        wf = window.Builder.buildWorkflowJSON(s, matchIndustryForScenario(s), { recommendedChannel: channelSel.value });
        aiBadge.textContent = 'AI: off';
      } else {
        throw e;
      }
    }

    lastWorkflow = wf;
    bpTA.value = JSON.stringify(wf, null, 2);
    downloadBtn.disabled = false;
    createBtn.textContent = 'Rebuild';
  } catch (e){
    dbg.innerHTML = '<span class="err">Build error:</span> ' + (e.message||String(e));
  } finally {
    createBtn.disabled = false;
  }
});

downloadBtn.addEventListener('click', async ()=>{
  try{
    if (!lastScenarioId) throw new Error('Create a workflow first.');
    // Stream direct from server so filename is correct, or fallback to local blob
    const dlUrl = `/api/build?scenario_id=${encodeURIComponent(lastScenarioId)}&download=1`;
    const r = await fetch(dlUrl, { cache:'no-store' });
    if (r.ok) {
      const blob = await r.blob();
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=`${lastScenarioId}.workflow.n8n.json`;
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    } else {
      if (!lastWorkflow) throw new Error('No workflow in memory.');
      const txt=JSON.stringify(lastWorkflow, null, 2);
      const blob=new Blob([txt],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=`${lastScenarioId}.workflow.n8n.json`;
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    }
  } catch (e){
    dbg.innerHTML = '<span class="err">Download error:</span> ' + (e.message||String(e));
  }
});

/* ========== Bootstrap (25 initial + search) ========== */
async function bootstrap(){
  try{
    const [sc, ind] = await Promise.all([
      getJSON('/api/scenarios?cursor=0&limit=25'),
      getJSON('/api/industries'),
    ]);
    const sitems = (sc.ok && sc.json && Array.isArray(sc.json.items)) ? sc.json.items : [];
    const iitems = (ind.ok && ind.json && Array.isArray(ind.json.items)) ? ind.json.items : [];
    ALL = sitems.map(normalizeScenarioRecord).filter(s=>s.scenario_id);
    MAP = Object.fromEntries(ALL.map(x=>[x.scenario_id,x]));
    INDUSTRIES = iitems.map(it=>({
      industry_id:it.industry_id||it.name||'',
      painpoints:it.core_pains||it.painpoints||'',
      kpis:it.success_metrics||it.kpi_examples||'',
      channels:it.channels||it.core_channels||'',
      vocabulary:it.agent_language_prompt||''
    })).filter(i=>i.industry_id);
    IND_MAP = Object.fromEntries(INDUSTRIES.map(it=>[(it.industry_id||'').toLowerCase(), it]));
    if (!ALL.length){
      const fallbackS={scenario_id:'tier1_dso_SCHEDULING_NO_SHOWS',name:'tier1_dso',agent_name:'Scheduling Agent',best_reply_shapes:['sms','email'],how_it_works:'Remind, confirm, backfill.',roi_hypothesis:'Reduce no-shows 30%+'};
      ALL=[fallbackS]; MAP={ [fallbackS.scenario_id]: fallbackS };
    }
    populateUI(ALL);
  } catch (e){
    dbg.innerHTML = '<span class="err">Bootstrap error:</span> ' + (e.message||String(e));
    const fallbackS={scenario_id:'tier1_dso_SCHEDULING_NO_SHOWS',name:'tier1_dso',agent_name:'Scheduling Agent',best_reply_shapes:['sms','email'],how_it_works:'Remind, confirm, backfill.',roi_hypothesis:'Reduce no-shows 30%+'};
    ALL=[fallbackS]; MAP={ [fallbackS.scenario_id]: fallbackS };
    populateUI(ALL);
  }
}
bootstrap();
</script>
</body>
</html>
